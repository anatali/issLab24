.. role:: red 
.. role:: blue 
.. role:: brown 
.. role:: magenta    
.. role:: remark
.. role:: worktodo
.. role:: slide
.. role:: slide1
.. role:: slide2
.. role:: slide3     
.. role:: slidekp 

.. _gradle : https://gradle.org/ 
.. _Leggi di Lehman : https://en.wikipedia.org/wiki/Lehman%27s_laws_of_software_evolution
.. _SOLID : https://clevercoder.net/2018/09/08/clean-architecture-summary-review/
.. _Clean Architecture : https://clevercoder.net/2018/09/08/clean-architecture-summary-review/
.. _Design Pattern : https://it.wikipedia.org/wiki/Design_pattern
.. _12FactorAppIllustrated : https://www.redhat.com/architect/12-factor-app

.. _MealyMachines : https://en.wikipedia.org/wiki/Mealy_machine
.. _MooreMAchines : https://en.wikipedia.org/wiki/Moore_machine

.. _gerarchia di Chomsky : https://it.wikiversity.org/wiki/Classificazione_delle_grammatiche

.. _Meta Object Facility: https://it.wikipedia.org/wiki/Meta-Object_Facility
.. _Ecore : https://wiki.eclipse.org/Ecore
.. _Linguaggio di modellazione : https://it.wikipedia.org/wiki/Linguaggio_di_modellazione
.. _Linguaggio formale : https://it.wikipedia.org/wiki/Linguaggio_formale
.. _Domain Specific Language: https://www.jetbrains.com/mps/concepts/domain-specific-languages/
.. _Linguaggi di programmazione: https://it.wikipedia.org/wiki/Linguaggio_di_programmazione
.. _Linguaggio assembly : https://it.wikipedia.org/wiki/Linguaggio_assembly
.. _Minsky Machine : https://en.wikipedia.org/wiki/Counter_machine
.. _Turing Machine : https://plato.stanford.edu/entries/turing-machine/
.. _Automa a stati finiti : https://it.wikipedia.org/wiki/Automa_a_stati_finiti
.. _pushdown automaton : https://it.wikipedia.org/wiki/Automa_a_pila
.. _Raspberry Pi TM : https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/turing-machine/one.html
.. _UML : https://it.wikipedia.org/wiki/Unified_Modeling_Language
.. _Use Cases Diagrams : https://it.wikipedia.org/wiki/Use_Case_Diagram
.. _User Stories : https://en.wikipedia.org/wiki/User_story
.. _Software testing : https://en.wikipedia.org/wiki/Software_testing 
.. _Software testing IBM : https://www.ibm.com/it-it/topics/software-testing
.. _Software testing quotes : https://softwaretestingfundamentals.com/software-testing-quotes/
.. _Automated-Testing-Plan FAQ : http://sqa.fyicenter.com/FAQ/Automated-Testing-Plan/
.. _Junit FAQ : http://sqa.fyicenter.com/FAQ/JUnit/What_Is_JUnit_.html
.. _DevOps : https://it.wikipedia.org/wiki/DevOps

.. _Meta Programming System : https://www.jetbrains.com/mps/
.. _Projectional editing : http://dsl-course.org/projectional-editing/
.. _Language-oriented programming : https://en.wikipedia.org/wiki/Language-oriented_programming

=====================================
Principi
=====================================


------------------------------
Sistemi
------------------------------

Un :blue:`sistema` può essere definito come l'unità fisica e funzionale, costituita da più parti 
o sottosistemi (organi, componenti o elementi ecc.) **interagenti** (o in relazione funzionale) tra loro 
(e con altri sistemi), che formano un tutt'uno in cui ogni parte dà il proprio contributo 
per una finalità comune.

- Sistemi fisici classici 
- Sistemi fisici quantistici   
- Sistemi logici (completi, consistenti, entrambi?)
- Sistemi meccanici 
- Sistemi statici e dinamici
- Sistemi deterministici e non
- Sistemi chiusi e sistemi aperti (all'informazione, all'energia, etc)
- Sistemi osservabili e/o interagibili
- Sistemi e proprietà: :ref:`Vista esterna` e :ref:`Vista interna`
- Sistemi che elaborano informazione: hardware e software
- Sistemi (software) concentrati e sistemi distribuiti
- Sistemi basati su (micro)servizi di elaborazione dell'informazione
- ...
- Sistemi viventi
- Sistemi auto-coscienti

WorldOnTurtle.png

Un sistema si può descrivere:

- Guardando dall'interno (riduzionismo / bottom-up)
- Guardando dall'esterno (olismo / top-down)

+++++++++++++++++++++++++++++++++++++++++
Vista esterna
+++++++++++++++++++++++++++++++++++++++++

Descrivere un sistema :blue:`dall'esterno` significa parlare di alcune 
proprietà 'macroscopiche' del sistema  (ad es. temperatura).

+++++++++++++++++++++++++++++++++++++++++
Vista interna
+++++++++++++++++++++++++++++++++++++++++

Descrivere un sistema :blue:`dall'interno` significa parlare di alcune 
proprietà 'microscopiche' dei costituenti del sistema  
(ad es. atomi) e derivare la proprietà macroscopiche (ad es. la temperatura)
da queste.

A livello di sistema, si possono presentare :slide1:`nuove proprietà`, che non possono essere dedotte dai suoi sottosistemi, 
ma che :slide1:`derivano dall'interazione delle parti`.

Si pensi, ad esempio, ad una molecola di acqua e ai suoi componenti H (idrogeno)
e O (ossigeno). Si pensi inoltre a un insieme di molte molecole di acqua.

------------------------------
Sistemi software
------------------------------

Rispetto alla semplice denominazione di *software*, l'uso del termine :blue:`sistema software` enfatizza 
in genere prodotti software complessi, e che sono costruiti o studiati in termini di macro-componenti, 
della loro organizzazione e delle loro interazioni. 


+++++++++++++++++++++++++++++++++++++++++
Viste di un sistema software
+++++++++++++++++++++++++++++++++++++++++

- La struttura di un sistema software è anche detta :blue:`architettura software`.
- Un sistema software può essere descritto da diversi punti di vista.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Vista esterna di un sistema
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

.. list-table:: 
  :widths: 25,75
  :width: 100%
  
  * - :slide2:`Vista esterna`
    
    - Il sistema  viene visto come una entità accessibile attraverso una API (Application Programming Interface)
      intesa come il punto di contatto che consente l'interazione tra codici in esecuzione

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Vista interna di un sistema
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

.. list-table:: 
  :widths: 25,75
  :width: 100%
  
  * - :slide2:`Vista interna`
    - Il sistema  viene visto come un insieme di enti computazionali (funzioni, oggetti, processi, etc.) che operano  
      interagendo tra loro e con il mondo esterno (clienti, dispositivi, etc.) usando adeguati supporti

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Vista sommersa
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

.. list-table:: 
  :widths: 25,75
  :width: 100%
  
  * - :slide2:`Vista sommersa`
    - Il sistema  è l'ultimo livello (:blue:`layer`) di uno stack i cui livelli sottostanti (sommersi)
      forniscono il supporto alla esecuzione. 

SoftwareLayersArch.PNG
      
      Procedendo dal livello più basso, di solito possiamo distinguere:  

      #. livello fisico (delle leggi fisiche)
      #. livello hardware
      #. livello del sistema operativo
      #. livello del linguaggio di programmazione (JVM Java)
      #. livello delle librerie di supporto


----------------------------
Dimensioni
----------------------------


La descrizione di un sistema software può avvenire 
focalizzando l'attenzione su almeno tre diversi punti di vista:


.. list-table::
  :widths: 50,50
  :width: 100%
  
  * - .. image:: ./_static/img/Architectures/Dimensioni.PNG
         :width: 100%
         :align: center
    -  
       - l'organizzazione del sistema in parti (**struttura**);
       - il modo in cui le diverse parti scambiano informazione implicita o esplicita tra loro (**interazione**);
       - il funzionamento del tutto e di ogni singola parte (**comportamento**).

------------------------------
Componenti software
------------------------------

Oggi è ormai scontata la transizione del software da una dimensioen di livello algoritmico 
a una dimensione  di tipo sistemistico che vede come componenti entità quali:


- funzioni 
- oggetti
- processi
- plugin, bundle ...
- attori
- servizi 
- microservizi

.. list-table::
  :widths: 50,50
  :width: 100%
  
  * - :remark:`Astrazioni di componenti software`
  
      .. image:: ./_static/img/Architectures/legendComponets.PNG
         :width: 30%
         :align: center 
    
    - :remark:`Astrazioni di interazione tra componenti software`
      
      .. image:: ./_static/img/Architectures/legendMessages.PNG
         :width: 44%    
         :align: center 

Per le figure è stato usato https://excalidraw.com/  

+++++++++++++++++++++++++++++++++++++++++++
Problematiche relative ai componenti
+++++++++++++++++++++++++++++++++++++++++++
 
- Come li individuo?
- Come li metto insieme?
- Come li rendo disponibili?
- Come li trovo/seleziono dinamicamente?
- Come li sostitusico?
- Come ne controllo/monitoro il funzionamento?
- Come specifico ciò che richiedono per funzionare?
- Come li progetto?
- Come li uso per costruire il sistema? (in modo top-down o botton-up?)
- Quali :ref:`Principi di costruzione` posso adottare?
  
------------------------------
Interazione
------------------------------

Le interazioni tra **oggetti** avvengono tramite :blue:`procedure-call`, cioè a trasferimento di controllo.

Le interazioni tra **componenti attivi** possono avvenire trameite :blue:`oggetti condivisi`, allocati su memoria comune,
oppure tramite :blue:`messaggi` che riguardano *informazioni* o *stream di dati* e che possono essere scambiati
in forma sincrona, asincrona o isocrona.

:slide:`Sincrono/Asincrono`

- In una interazione **asincrona**, la comunicazione è "bufferizzata" senza alcuna 
  limitazione sulle dimensioni del buffer. 
  L'emittente non deve attendere alcuna informazione di ritorno anche quando invia informazione 
  ad uno specifico destinatario. Il ricevente attende solo quando il buffer è vuoto. 
  Nel caso di stream, non vi sono vincoli di tempo per la ricezione.

- In una interazione **sincrona**, la comunicazione avviene senza l'uso di alcun buffer. 
  L'emittente e il desinatario scambiano informazione unificando concettualmente le proprie attività. 
  Nel caso di stream, il destinatario si aspetta di ricevere i dati con un ritardo (delay) 
  che non supera un massimo prefissato.

- Una interazione **isocrona** riguarda solo stream; il destinatario si aspetta di ricevere i dati 
  con un delay compreso tra un minimo e un massimo.

Le interazioni a messaggi vengono anche spesso suddivise secondo quattro pattern principali:

- **Fire and forget**: il caso di invio di  messaggi.
- **Sync with server**: il caso request-response.
- **Poll objects**: il sender invia una request delegando ad un oggetto (*poll object*) la responsabilità 
  di ricevere la risposta. Il sender usa il poll object per verificare ed acquisire la disponibilità della risposta.
- **Result callback**: il sender invia una request specificando un oggetto (*callback object*) che implementa 
  un metodo che verrà invocato dal supporto non appena il receiver invierà la risposta.

Questi punti costituiscono il cuore del passaggio da ``OOP`` a message-passing.


:slide:`Termini in uso nel corso`

++++++++++++++++++++++++++++++++++++++
Terminologia di riferimento
++++++++++++++++++++++++++++++++++++++

Faremo riferimento alla seguente terminologia:


- **Messaggio** (:blue:`message`): termine generico per denotare informazione scambiata mediante
  l'uso di un opportuno supporto di comunicazione.
- **Dispaccio** (:blue:`dispatch`): messaggio inviato in modo asincrono a N (N>=1) specifici destinatari, 
  noti alla emittente, con l'aspettativa che questi lo ricevano e lo elaborino; l'emittente non si aspetta 
  alcuna informazione di ritorno.  
- **Invito** (:blue:`invitation`): messaggio inviato a N (N>=1) destinatari, con l'aspettativa che almeno uno lo riceva 
  e invii al mittente un messaggio di *conferma*.
- **Conferma** (:blue:`ack`): messaggio inviato al mittente di un *invitation*. 
  Il contenuto del messaggio rappresenta un riconoscimento di avvenuta ricezione.
- **Richiesta** (:blue:`request`): messaggio inviato a uno specifico destinatario; il contenuto del messaggio 
  rappresenta la richiesta di esecuzione di una attività, con aspettativa da parte del mittente 
  che questa attività si concluda con una risposta pertinente alla richiesta.
- **Risposta** (:blue:`reply, response`): messaggio inviato da un destinatario al mittente di una richiesta.
  il contenuto del messaggio rappresenta informazione pertinente alla richiesta.
- **Evento** (:blue:`event`): messaggio emesso (più o meno consapevolmente) in modo asincrono da una sorgente 
  senza alcuna particolare nozione di destinatario e senza alcuna aspettativa da parte dell'emittente.
- **Segnale** (:blue:`signal`): messaggio emesso in modo consapevole e asincrono a N (N>=1) destinatari, 
  noti o meno all'emittente, 
  con l'aspettativa che venga ricevuto da qualcuno, al fine di eseguire un'azione che potrebbe portare vantaggio 
  all'emittente, al ricevente e/o al sistema nel suo complesso.

-----------------------------------------------
Interazioni dal punto di vista applicativo
-----------------------------------------------

In un sistema distribuito:

- I componenti-base sono enti attivi, che d'ora in poi possiamo denominare, genericamente, :blue:`attori`.
- Gli attori **non hanno memoria comune** e scambiano informazione tramite :blue:`messaggi`.
- Si distinguono diversi tipi di messggio, descritti nella :ref:`Terminologia di riferimento`. In sintesi:
  
    .. code::  

        enum ApplMessageType{ event, dispatch, request, reply, invitation}   

  .. list-table:: 

     * - 
         - :blue:`dispatch`: un messaggio inviato a un preciso destinatario senza attesa  di una risposta 
           (in modo detto anche  `fire-and-forget`);
         - :blue:`invitation`: un messaggio inviato a un preciso destinatario aspettandosi un 'ack' da parte di questi;
         - :blue:`request`: un messaggio inviato a un preciso destinatario aspettandosi da parte di questi una 
           :blue:`reply` **logicamente correlata alla richiesta**;
         - :blue:`event`: un messaggio inviato a chiunque sia in grado di elaborarlo.

       - .. image:: ./_static/img/Architectures/legendMessages.PNG
             :align: center
             :width: 50%

- I messaggi sono trasmessi e ricevuti tramite un qualche :blue:`supporto fisico` che permette scambio di informazione.
- Gli attori di un sistema si conoscono grazie ai loro :blue:`nomi` e non attraverso l'uso di un particolare supporto 
  di comunicazione.
- La interazione tra attori è, di base, :blue:`asincrona`. Se un attore ``A`` invia a un altro attore  ``B``
  un messaggio :blue:`request`, allora:

  - L'attore ``A`` potrebbe proseguire nella sua esecuzione e decidere di 
    elaborare la :blue:`reply` in un secondo momento.  
  - Oppure, ``A``  potrebbe decidere di non fare altro prima della ricezione della :blue:`reply`.
  - Un messaggio :blue:`reply` viene di norma inviato ad ``A`` da ``B``, ma potrebbe anche accadere che venga inviato da un altro 
    attore ``C`` (delegato da ``B``).
- Un attore potrebbe emettere informazione senza un preciso destinatario. Noi denominiamo tale informazione come :blue:`evento`.
- L'emissione di un :blue:`event` da parte di un attore :blue:`rende l'attore osservabile`, 
  senza interferenze dirette da parte degli eventuali observer. Notiamo però che:

  - Un attore può anche essere reso osservabile se capace di rispondere a   :blue:`request` di interesse da parte 
    di altri attori.

------------------------------
Comportamento
------------------------------

Per esprimere il comportamento di un componente software, si distinguono classicamente tre diversi 'stili':

- imperativo
- funzionale
- logico-dichiarativo

Il funzionamento di un componente comporta spesso l'individuazione 
di un insieme di :slide1:`operazioni primitive`, sulla base delle quali costruire ogni altra operazione 
di manipolazione/gestione del componente.  

Si pensi per esempio al caso di un *oggetto lista*, le cui primitive 
sono il costruttore ``cons``, i selettori ``head, tail`` e il predicato ``empty``. Un volta data la lista vuota (l'oggetto ``emptyList``)
ogni lista può essere costruita e manipolata attraverso l'uso di queste primitive.

:slide:`Macchine astratte`

.. list-table::
  :widths: 50,50
  :width: 100%
  
  * - Spesso si qualifica il comportamento di un componente facendo riferimento a tipi diversi di 
      :blue:`macchine astratte`, iniziando dalla 
      `Turing Machine`_ (**TM**), che individua, in stile imperativo, le mosse-base (*primitive*) 
      di un automa che permette di :remark:`realizzare qualunque calcolo` (!).
    - .. image:: ./_static/img//Intro/TuringMachine.PNG
        :width: 100%
        :align: center
      
      Si veda `Raspberry Pi TM`_


.. list-table::
  :widths: 50,50
  :width: 100%
  
  * - Un automa equivalente che ottiene lo stesso risultato con una sorta di `Linguaggio assembly`_ minimale è la
      `Minsky Machine`_ (nota anche come *Counter Machine*) 
    - .. image:: ./_static/img//Intro/MinskyMachine.PNG
        :width: 100%
        :align: center


Un tipo meno potente di macchina astratta rispetto alla **TM** è il `pushdown automaton`_ (**PDA**) che però è l'automa 
di riferimento per il riconoscimento delle frasi di un inguaggio con *sintassi context-free*, di tipo 2 nella 
`gerarchia di Chomsky`_ . 


:slide:`FSM di Moore e Mealy`

++++++++++++++++++++++++++++++++++++++
Automi a stati finiti
++++++++++++++++++++++++++++++++++++++

Un ulteriore tipo di automa meno potente della TM, ma su cui si fonda sia la TM sia il PDA 
è l'`Automa a stati finiti`_ (*Finite State Machine* - **FSM**)
il cui funzionamento può essere formalmente descritto da una 5-tuple (``States, Inputs, Outputs, Transitions, InitialState``):

- **States**: insieme di possibili stati in cui l'automa si può trovare.
- **Inputs**: insieme delle informazioni di ingresso, denotabili attraverso un *input alphabet*; nel nostro caso 
  possiamo pensare che ogni simbolo dell'alfabeto  denoti un messggio.
- **Outputs**: insieme della informazioni di uscita, denotabili attraverso un *output alphabet*;   nel nostro caso 
  possiamo pensare che ogni simbolo dell'alfabeto denoti una **azione**.
- **InitialState**: lo stato iniziale (unico) in cui l'automa si trova quando viene creato.
- **Transizione**: definisce il nuovo stato e l'output dell'automa in funzione dello stato corrente e del simbolo corrente in ingresso.
  E' spesso espressa da una coppia di funzioni:

   .. code ::

      nextState:      States x Inputs -> States
      output:         States x Inputs -> Outputs

Normalmente, gli automi a stati finiti si suddividono in due grandi categorie:

- `MealyMachines`_: una FSM il cui output è determinato sia dallo stato corrente sia dall'input corrente.
- `MooreMachines`_: una FSM il cui output dipende unicamente dallo stato corrente (``SCUR``) in cui l'automa si trova.

**FSM** di tipo  `MooreMachines`_ avranno per noi un ruolo fondamentale.
Quando l'automa si trova nello stato corrente ``SCUR``:

#. esegue una sequenza (che **deve terminare**) di azioni;
#. al termine della sequenza di azioni controlla che vi sia almeno un input (messaggio) 
   capace di attivare una delle transizioni verso un ulteriore stato (``SNEXT``);
#. attiva una delle transizioni possibili pasando dallo stato ``SCUR`` allo stato ``SNEXT`` (che potrebbe anche coincidere
   con ``SCUR``);
#. se non vi sono transizioni attivabili, rimane nello stato ``SCUR`` da cui potrà sbloccarsi solo in conseguenza di un 
   ulteriore messaggio di input.


--------------------------------------------
Principi di costruzione
--------------------------------------------

Nel corso degli anni si sono imposti alla attenzione degli sviluppatori,
alcuni principi, metodologie, schemi di riferimento etc. che aiutano nella progettazione e sviluppo
di sistemi software.

Qui ne ricordiamo alcuni, che useremo nel seguito.

:slide:`Design patterns`

++++++++++++++++++++++++++++
Design patterns
++++++++++++++++++++++++++++

.. list-table::
  :widths: 40,60
  :width: 100%
  
  * - Agli anni 90 del secolo scorso risale l'idea di :blue:`pattern`, culminata nella pubblicazione 
      nel ``1995`` dell'ormai famoso testo sui `Design Pattern`_  della così detta *Gang-of-Four*
      (**GoF**): *Erich Gamma, Richard Helm, Ralph Johnson e John Vlissides*).

    - .. image:: ./_static/img/Intro/DesignPatternGof.PNG
         :width: 100%
         :align: center

:slide1:`Pattern POSA`

.. list-table::
  :widths: 40,60
  :width: 100%
  
  * - Da allora si sono susseguiti molte altre conferenze e lavori. 
      I riferimenti più noti sono i cinque testi ``POSA`` (si veda in :ref:`books`) sulle *Pattern oriented Software Architectures*
      e i convegni ``PLoP`` (*Pattern Languages of Programming*).

    - .. image:: ./_static/img/Intro/Posa.PNG
         :width: 100%
         :align: center


:slide:`Principi SOLID`

++++++++++++++++++++++++++++
SOLID
++++++++++++++++++++++++++++


Dal sito `Clean Architecture`_ (Uncle Bob) leggiamo:

- :blue:`Single responsibility principle` : una classe dovrebbe avere una, e una sola, ragione per cambiare.
- :blue:`Open-closed principle` : una classe dovrebbe essere aperta per l'estensione ma chiusa per la modifica.
- :blue:`Liskov’s substitution principle` : gli oggetti in un programma dovrebbero essere sostituibili con istanze dei loro sottotipi senza alterare la correttezza di quel programma.
- :blue:`Interface segregation principle` : molte interfacce specifiche del client sono migliori di un'interfaccia generica.
- :blue:`Dependency inversion principle` : si dovrebbe dipendere dalle astrazioni, non dalle implementazioni. 
    

++++++++++++++++++++++++++++
Dependency inversion 
++++++++++++++++++++++++++++

Se il codice sorgetne di un componente di alto livello dipende da quello di un componente di basso livello,
i cambiamenti nei componenti di basso livello si diffonderanno al componente di alto livello. 
Pertanto, poniamo un confine tra i due, :remark:`usando il polimorfismo per invertire il flusso logico`. 

Questo è il principio di inversione della dipendenza. Vediamo un esempio, preso da `Clean Architecture`_:

.. list-table::
  :widths: 40,60
  :width: 100%
  
  * - .. image:: ./_static/img/Architectures/EsempioInversioneDip.PNG
         :width: 100%
         :align: center
    -   Le regole aziendali dipendono dall'interfaccia anziché dalla classe di database concreta.
        
        Il database diventa un plug-in delle regole aziendali: un componente di basso livello
        che può essere modificato senza influenzare le regole aziendali (componente di alto livello).



:slide:`Architettura Port/Adapter`

++++++++++++++++++++++++++++
Architettura esagonale
++++++++++++++++++++++++++++

L'architettura esagonale (anche nota come :ref:`Port-Adapter<Architettura Esagonale (Port-Adapter)>`) è, 
tra le tante :ref:`Architetture` 
di sistemi software oggi in uso, quella cui noi faremo particolare attenzione.

.. list-table::
  :widths: 60,40
  :width: 100%
  
  * - .. image:: ./_static/img/Architectures/portAdapterArch.PNG
         :width: 100%
         :align: center
    -  Si identificano quattro layer principali
       
       - :blue:`Entities`: oggetti che contengono la logica aziendale critica.
       - :blue:`Use-cases`: regole aziendali specifiche dell'applicazione
       - :blue:`Interface adapters`: gateway, presentatori e controller. Ad esempio, questo livello contiene l'architettura MVC della GUI e anche oggetti che trasformano i dati tra il formato del database e i casi d'uso.
       - :blue:`Frameworks and drivers`: framework web, database, la vista di MVC


:slide:`REST`

++++++++++++++++++++++++++++
Lo stile REST
++++++++++++++++++++++++++++

:blue:`Representational state transfer` è uno **stile architetturale per sistemi distribuiti**. 
L'espressione "representational state transfer" e il suo acronimo, 
``REST``, fu introdotto nel 2000 nella tesi di dottorato di Roy Fielding,

``REST`` rappresenta un sistema di trasmissione di dati su HTTP senza ulteriori livelli, quali ad esempio SOAP. 
I sistemi REST non prevedono il concetto di sessione, ovvero sono :slide2:`stateless`.

L'architettura ``REST`` si basa su HTTP. 
Il funzionamento prevede una struttura degli ``URL`` ben definita che identifica univocamente una :slide2:`risorsa` 
o un insieme di risorse e l'utilizzo dei metodi ``HTTP`` specifici per il recupero di informazioni (:blue:`GET`), 
per la modifica (:blue:`POST`, :blue:`PUT`, :blue:`PATCH`, :blue:`DELETE`) e per altri scopi (:blue:`OPTIONS`, ecc.). 


``REST`` prevede che la scalabilità del Web e la crescita siano risultati di pochi principi chiave di progettazione:

- lo stato dell'applicazione e le funzionalità sono divisi in risorse web
- ogni risorsa è unica e indirizzabile usando sintassi universale per uso nei link ipertestuali
- tutte le risorse sono condivise come interfaccia uniforme per il trasferimento di stato tra client e risorse, questo consiste in:

  - un insieme vincolato di operazioni ben definite
  - un insieme vincolato di contenuti, opzionalmente supportato da codice a richiesta
  - un protocollo che è:
   
    - client-server
    - privo di stato (stateless)
    - memorizzabile in cache
    - a livelli.

:slide:`Principi per WebApp`


++++++++++++++++++++++++++++
Il protocollo Coap
++++++++++++++++++++++++++++

:blue:`Constrained Application Protocol` (``CoAP``)
è un protocollo di trasferimento web che si basa sullo stile architettonico :ref:`REST<Lo stile REST>` 
e consente di manipolare le risorse di comunicazione di oggetti e sensori utilizzando un modello 
di interazione client-server.

CoAP è uno dei protocolli più utilizzati per l’implementazione dell'Internet of Things e viene considerato 
come la versione leggera di ``HTTP``, anche se in realtà esistono alcune differenze, 
prima su tutte l’utilizzo di ``UDP`` (e non ``TCP``) per la comunicazione.

È stato progettato per lavorare in ambienti limitati, con scarsa larghezza di banda ed energia, 
e dove è necessaria una comunicazione rapida e ininterrotta. 
È questo il motivo per cui viene utilizzato ``UDP`` per la comunicazione: 
consentire una comunicazione più veloce migliorando gli scambi di dati ``M2M`` (Machine to Machine), 
``D2D`` (Device to Device) e ``D2G`` (Device to Gateway).




++++++++++++++++++++++++++++
12 Factor App
++++++++++++++++++++++++++++

Una delle soluzioni oggi adottate per affrontare i problemi di operare su scala Web,
è la metodologia :blue:`Twelve-Factor App`, pubblicato nel ``2011`` da Adam Wiggins. 

La :blue:`12 Factor App` è un insieme di principi per la creazione di applicazioni :remark:`software-as-a-service`,
che descrivono un modo di creare software che consente alle aziende di 
creare codice che può essere rilasciato in modo affidabile, ridimensionato rapidamente e mantenuto 
in modo coerente e prevedibile.
 
.. Queste best practice sono progettate per consentire la creazione di applicazioni con portabilità  e resilienza quando distribuite sul Web. 
.. https://12factor.net/it/

#. :blue:`Codebase`: Una sola codebase sotto controllo di versione, tanti deployment.
#. :blue:`Dipendenze`: Dipendenze dichiarate e isolate; nessun affidamento implicito su strumenti o librerie di sistema.
#. :blue:`Configurazione`: Memorizza le informazioni di configurazione nell’ambiente.
#. :blue:`Baking service`: I servizi di supporto vengono trattati come risorse collegate e scollegate dall'ambiente di esecuzione.
#. :blue:`Costruisci, rilascia, esegui`: Separare in modo netto lo stadio di build dall'esecuzione
#. :blue:`Processi`: Esegui l'applicazione come uno o più processi stateless. I dati persistenti sono archiviati su un servizio di supporto
#. :blue:`Binding delle Porte`: I servizi autonomi dovrebbero rendersi disponibili ad altri servizi tramite porte specificate.
#. :blue:`Concorrenza`: La concorrenza è sostenuta dal ridimensionamento dei singoli processi.
#. :blue:`Disponibilità`: Massimizzare la robustezza con avvii veloci e chiusure non brusche.
#. :blue:`Parità Sviluppo/Produzione`: Tutti gli ambienti dovrebbero essere il più simili possibile.
#. :blue:`Log`: Tratta i log come stream di eventi e lascia l'ambiente di esecuzione per l'aggregazione.
#. :blue:`Processi di Amministrazione`: Tutte le attività di amministrazione necessarie devono essere mantenute nel controllo 
   del codice sorgente e incluse nel pacchetto dell'applicazione.

Si veda  anche: `12FactorAppIllustrated`_

.. https://en.wikipedia.org/wiki/Twelve-Factor_App_methodology


:slide:`Linguaggi`


++++++++++++++++++++++++++++
Linguaggi di programmazione
++++++++++++++++++++++++++++

Costrutti per esprimere strutture (di dati e di controllo), forme di comportamento e meccanismi di interazione 
sono presenti in tutti i `Linguaggi di programmazione`_.

Un punto importante consiste nel capire fino a che punto i costrutti di un linguaggio debbano influenzare 
il progettista (se non lo stesso analista). 
Fino alla fine degli anni 90 il linguaggio di programmazione è stato il veicolo principale per introdurre 
nuovi concetti sia sul piano computazionale sia sul sul piano della organizzazione del software.

.. list-table::
  :widths: 40,60
  :width: 100%
  
  * - .. image:: ./_static/img/Intro/historyHLPL.PNG
         :width: 100%
         :align: center
    - La figura  mostra una visione sintetica dello sviluppo nel tempo di questa evoluzione linguistica,
      con riferimento ad alcuni dei linguaggi più noti (in `Linguaggi di programmazione`_ si dice che oggi
      si usano più di 2500 linguaggi di programmazione).

      L'avvento della programmazione ad oggetti sembra avere segnato il culmine di questo processo; 
      un motivo può certo essere il raggiungimento di una sufficiente maturità nella capacità espressiva 
      in ciascuna delle :ref:`Dimensioni` citate.
 

:slide1:`Sintassi astratta`
 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Sintassi astratta  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Il motivo principale di una relativa (e solo apparente) 
stagnazione nello sviluppo di nuovi linguaggi, può essere ricondotto all'idea che un linguaggio 
non deve essere necessariamente accompagnato da una sintassi concreta ma può essere suffciente 
definire una **sintassi astratta** utilizzando un :blue:`meta-linguaggio` 

Il `Meta Programming System`_ (**MPS**) di IntelliJ  offre un editor (si veda  `Projectional editing`_) 
che costituisce una *proiezione della sintassi astratta* (**AST**) di un meta-linguaggio per la definizione di 
:ref:`Domain Specific Languages` (**DSL**).

.. slide1:`Programmazione orientata al linguaggio`

`Language-oriented programming`_ è un paradigma di sviluppo del software  che 
incoraggia esplicitamente gli sviluppatori 
a creare i propri DSL o ad estendere i linguaggi esistenti con concetti specifici del dominio.

.. https://en.wikipedia.org/wiki/Language-oriented_programming

.. Il Meta-Programming System (MPS) di JetBrains



.. Questa idea ha come riferimento i `Domain Specific Languages`_.
 
.. https://www.jetbrains.com/help/mps/fast-track-to-mps.html#step5-projectionaleditingtipsandtricks



.. https://medium.com/@mikhail.barash.mikbar/a-tale-about-domain-specific-languages-bde2ace22f6c


:slide1:`Domain Specific Languages`


----------------------------------------
Domain Specific Languages
----------------------------------------
.. https://www.jetbrains.com/mps/whatsnew/

.. https://www.jetbrains.com/help/mps/fast-track-to-mps.html#step3-mpsfromtheprogrammersperspective
.. https://www.youtube.com/watch?v=1Dx4yrd5ISQ
.. https://lp.jetbrains.com/mps-in-academia/

.. https://medium.com/@mikhail.barash.mikbar/looking-at-code-through-the-prism-of-jetbrains-mps-8e9b70e3257d IMPORTANTE
.. https://www.jetbrains.com/help/mps/basic-notions.html#generator  IMPORTANTE
.. https://www.youtube.com/watch?v=iN2PflvXUqQ  MPS Projectional editor

.. https://martinfowler.com/articles/mpsAgree.html            FOWLER 2005
.. https://martinfowler.com/articles/languageWorkbench.html   FOWLER 2005

.. https://www.youtube.com/watch?v=6FaIPPUgiDI  KAJA
.. https://www.youtube.com/watch?v=OyIj5D6ORXs

.. https://www.jetbrains.com/help/mps/shapes-an-introductory-mps-tutorial.html FORME
.. https://www.youtube.com/watch?v=Mb1QzHx83M4

.. https://www.jetbrains.com/help/mps/mps-calculator-language-tutorial.html CALCULATOR

 
Un `Domain Specific Language`_ (**DSL**) è un linguaggio che aumenta il livello di astrazione oltre la programmazione,
utilizzando direttamente concetti e regole da uno specifico dominio del problema
 

Tra i vantaggi dell'uso di un DSL:

- usando un DSL e un *motore di trasformazione*, il  lavoro nel particolare aspetto dello sviluppo 
  del software coperto dal DSL diventa molto più efficiente, perché il lavoro di colmare l'abstraction gap 
  vine svolto dal motore di trasformazione;
- l'uso di *astrazioni specifiche del dominio* può avvenire senza sovraccarico runtime, 
  perché il motore di trasformazione, proprio come un compilatore, può rimuovere le astrazioni 
  e generare codice efficiente;
- il *modo di pensare* del progettista software diventa più chiaro perché il codice non è ingombrato 
  dai dettagli dell'implementazione;
- la *logica dell'applicazione* espressa nel codice DSL è indipendente dalla piattaforma di destinazione;  
- si promuove un'ottima *integrazione* tra gli svluppatori software e gli esperti del dominio.






:slide:`I modelli`

++++++++++++++++++++++++++++
Modelli
++++++++++++++++++++++++++++
Nel linguaggio comune, il termine :blue:`modello` è spesso usato per denotare un'astrazione 
di qualcosa che esiste nella realtà, come ad esempio il modello che posa per un artista, 
una riproduzione in miniatura, un esempio di modo di svolgere un'attività, una forma 
da cui ricavare vestiti, un ideale da seguire, etc.. 

Alcuni (tra cui gli ingegneri) intendono per modello un sistema matematico o fisico che ubbidisce 
a specifici vincoli e che può essere utilizzato per descrivere e comprendere un sistema 
(fisico, biologico, sociale, etc.) attraverso relazioni di analogia.

:slide1:`Modello=rappresentazione dell'essenza di un sistema`

.. list-table::
  :widths: 60,40
  :width: 100%
  
  * - .. image:: ./_static/img/Intro/Modello.PNG
         :width: 70%
         :align: center
    - .. image:: ./_static/img/Intro/ModelloNumeri.PNG
         :width: 100%
         :align: center
 
.. Nel contesto dei processi di costruzione del software, il termine modello va primariamente 
.. inteso come un insieme di concetti e proprietà volti a catturare aspetti essenziali di un sistema, 
.. collocandosi in un preciso spazio concettuale.   


.. Per l'ingegnere del software quindi un modello costituisce una visione semplificata di un sistema 
.. che rende il sistema stesso più accessibile alla comprensione e alla valutazione e facilita 
.. il trasferimento di informazione e la collaborazione tra persone, 
.. soprattutto quando è espresso in forma visuale.
 


Nel concepire un modello come visione semplificata di un sistema software si assume che il sistema 
abbia già una sua esistenza concreta. 
In alcune fasi di lavoro (in particolare nella fase di analisi) il sistema è il modello; 
un raffinamento o una variazione del modello corrisponde in questo caso ad una variazione del sistema.

La produzione esplicita di modelli si rivela utile in quanto i diversi attori di un processo 
di produzione di software (committenti, analisti, progettisti, utenti, etc) 
operano a diversi livelli di astrazione e con fini diversi. 

Definendo opportuni modelli del sistema da realizzare, in ogni fase del processo di produzione 
l'attenzione può essere focalizzata sugli aspetti rilevanti in quella fase, utilizzando una 
forma di comunicazione comprensibile ad attori diversi. 
Per garantire coesione e interoperabilità, si cerca di individuare regole di corrispondenza 
e di trasformazione automatica tra modelli.


++++++++++++++++++++++++++++++++++++++
Linguaggi di (meta)modellazione
++++++++++++++++++++++++++++++++++++++

Un `Linguaggio di modellazione`_ è un `Linguaggio formale`_ 
che può essere utilizzato per descrivere (modellare) un sistema di qualche natura.

UML (*Unified Modeling Language*) è un linguaggio di modellazione e di specifica 
di sistemi software basato sul paradigma orientato agli oggetti. Il linguaggio è definito in termini
di un linguaggio di meta-modellazione denominato ``MOF``
(si veda `Meta Object Facility`_) .

.. list-table::
  :widths: 60,40
  :width: 100%
  
  * - .. image:: ./_static/img/Intro/mofUml.PNG
         :width: 100%
         :align: center
    - La `Meta Object Facility`_ di UML2 nella versione incorporata in Eclipse
      (denominata `Ecore`_) può essere usata per definire un linguaggio che permette di esprimere sistemi software come
      oggetti attivi (**attori**) che interagiscono tra loro a scambio di messaggi si comportano come `MooreMachines`_.


Nel contesto dell'ingegneria del software, ``UML`` viene usato soprattutto per descrivere il dominio applicativo 
di un sistema software e/o il comportamento e la struttura del sistema stesso. 

Il modello è strutturato secondo un **insieme di viste** che rappresentano diversi aspetti della cosa modellata 
(funzionamento, struttura, comportamento e così via), a scopo sia di analisi sia di progetto, 
mantenendo la tracciabilità dei concetti impiegati nelle diverse viste.

:slide:`Il testing`

++++++++++++++++++++++++++++
Testing
++++++++++++++++++++++++++++


L’obiettivo della fase di testing è quello di trovare il maggior numero di situazioni che conducono ad errori 
con il minimo numero di casi di prova. 
Un  piano di testing  ha di solito lo scopo di stabilire la gerarchia con cui i test vanno eseguiti, 
i metodi di esecuzione, i criteri di accettazione e prevede diverse tipologie di test, tra cui:


- **Unit test** (Test di unità o di modulo)
  Ha l’obiettivo di individuare gli errori nel singolo modulo software. 
 
- **Integration Test** (Test di integrazione)
  Ha l’obiettivo di individuare gli errori nel software quando tutti i moduli che compongono un sottosistema 
  o l’intero sistema vengono fatti lavorare assieme. 

- **System Test** (Test di sistema)
  Ha l’obiettivo di garantire che il prodotto software nel suo complesso soddisfi completamente 
  i requisiti iniziali. E' un collaudo interno. 

- **User Acceptance Test** (Test di accettazione)
  Ha l’obiettivo di valutare la rispondenza dell’applicazione software rispetto ai requisiti 
  espressi inizialmente nel contratto e di ottenere l’accettazione formale del cliente di quanto realizzato. 
  Il test viene effettuato dal cliente nel suo ambiente di test, e da un gruppo di utenti. 

- **Alpha test e Beta test**
  Un :blue:`alpha test` è un test preliminare di un’applicazione software anche non ancora completa, 
  eseguito da alcuni potenziali utenti rappresentati da un team. 

  Un :blue:`beta test` ha l’obiettivo di far valutare al cliente, prima della distribuzione ufficiale del sistema, 
  la reale funzionalità, completezza ed operatività dell’applicazione. 
  
- **Regression Test** (test di non regressione)
  Ha l’obiettivo di verificare a valle di una manutenzione, dopo che un bug è stato individuato e corretto 
  e sono stati eseguiti esattamente gli stessi test che erano stati effettuati quando era stato individuato il problema.

- **Stress test** (test di carico)
  Ha l’obiettivo di determinare il punto di rottura di un sistema software, 
  oltre il quale si verificano instabilità del sistema, perdita dei dati o interruzione del servizio.


Sul problema del testing si trova moltissimo materiale in rete. Riportiamo qui alcuni riferimenti utili sul 'piano pragmatico':

- `Software testing`_ (wikipedia)
- `Software testing quotes`_
- `Automated-Testing-Plan FAQ`_
- `JUnit FAQ`_


++++++++++++++++++++++++++++++++
Dal testing a DevOps
++++++++++++++++++++++++++++++++


La fase di testing del software è  attività imprescindibile per garantirne la qualità ed è anche 
indispensabile per garantire all’utente una *user experience* soddisfacente. 

In `Software testing IBM`_  leggiamo che:

- Negli anni '90 c'è stata una transizione dai test a un processo più completo denominato 
  :blue:`controllo di qualità`, che copre l'intero ciclo di sviluppo del software e riguarda 
  i processi di pianificazione, progettazione, creazione ed esecuzione di casi di test. 
- I test del software sono stati tradizionalmente separati dal resto dello sviluppo, ma
  molti team di sviluppo  usano ora una metodologia nota come :blue:`test continuo`. 
  
Il *test continuo* è parte dell'approccio `DevOps`_, in cui sviluppo e operazioni collaborano 
per l'intero ciclo di vita del prodotto. L'obiettivo è quello di accelerare la fornitura del software, 
bilanciando al tempo stesso i costi, la qualità e i rischi.   

Noi porremo particolare attenzione al fatto che la definizione di test (autmatizzabili) può essere vista come
la **formalizzazione** delle `User Stories`_  e che l'uso dei modelli (esguibili) può permettere 
di anticipare questa formalizzazione fin dalle fasi di analisi.

Nella fase di analisi, l'obiettivo non è quello di eseguire dei test, ma quello di trovare il modo migliore 
per definire i test in modo che possano individuare in modo automatico le falle del software rispetto ai requisiti.

L'obiettivo di definire un TestPlan automatizzabile introduce di fatto un **nuovo requisito**: 
:blue:`rendere  l'applicazione osservabile`, o meglio:

:remark:`renderne verificabili, da parte di una macchina, gli effetti dell'applicazione`.


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Progettazione e sviluppo come processo evolutivo
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

L'uso dei modelli è utile (per non dire indispensabile) PER CONCENTRARE
l'attenzione SUGLI ASPETTI RITENUTI SALIENTI (tenendo conto anche
dei tempi, delle tecnologie disponibili  e dei costi).

Come già previsto da `UML`_, è opportuno definire modelli come risultato delle 
fasi di analisi dei requisiti (*Use Case Diagrams*), analisi del problema 
e del progetto (*class diagrams, sequence diagrams*, *activity diagrams*, *statechart diagram* ) 
e anche per la distribuzione del prodotto (*deployment diagrams*).

L'architettura logica espressa mediante un modello esguibile del sistema da realizzare,
condiviso tra tutti (customer, responsabili aziendali, sviluppatori), è un importante e solido punto di partenza
per la progettazione della soluzione, cioè per il passaggio da WHAT a HOW.
Questo passaggio può essere visto e svolto come un :blue:`processo evolutivo` di trasformazione/specializzazione di questa
architettura di base. 

Il modello della architettura logica può essere anche il riferimento per la impostazione di
PIANI di testing espressi in MODO NON discorsivo (formale), comprensibile a una macchina. 

Noi seguiremo questa idea con lo sviluppo  di
un meta-modello custom che permette la definizione di modelli eseguibili di sistemi distributi.
