
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>ISS2024 &#8212; iss24 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/nature.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="QakService24Usage" href="QakService24Usage.html" />
    <link rel="prev" title="Intro2024" href="Intro2024.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="QakService24Usage.html" title="QakService24Usage"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="Intro2024.html" title="Intro2024"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">iss24 1.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ISS2024</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="iss2024">
<h1>ISS2024<a class="headerlink" href="#iss2024" title="Permalink to this heading">¶</a></h1>
<section id="intro2024-indice">
<h2>Intro2024 indice<a class="headerlink" href="#intro2024-indice" title="Permalink to this heading">¶</a></h2>
<ol class="arabic simple">
<li><p><a class="reference internal" href="Intro2024.html#intro2024"><span class="std std-ref">Introduzione</span></a></p></li>
<li><p><a class="reference internal" href="#promesse-del-corso"><span class="std std-ref">Promesse del corso</span></a></p></li>
<li><p><a class="reference internal" href="#il-metodo-di-lavoro"><span class="std std-ref">Il metodo di lavoro</span></a></p></li>
<li><p><a class="reference internal" href="#fasi-del-corso"><span class="std std-ref">Fasi del corso</span></a></p></li>
<li><p><a class="reference internal" href="#criteri-di-valutazione"><span class="std std-ref">Criteri di valutazione</span></a></p></li>
<li><p><span class="xref std std-ref">Towards2024</span></p></li>
</ol>
<p><span class="slide2">LINKS</span></p>
<table class="docutils align-default" style="width: 100%">
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Insegnamento</p></td>
<td><p><a class="reference external" href="https://www.unibo.it/it/didattica/insegnamenti/insegnamento/2023/468003">https://www.unibo.it/it/didattica/insegnamenti/insegnamento/2023/468003</a></p></td>
</tr>
<tr class="row-even"><td><p>Virtuale</p></td>
<td><p><a class="reference external" href="https://virtuale.unibo.it/course/view.php?id=35152">https://virtuale.unibo.it/course/view.php?id=35152</a></p></td>
</tr>
<tr class="row-odd"><td><p>Wooclap</p></td>
<td><p><a class="reference external" href="https://app.wooclap.com/events/ISS24STARTING">https://app.wooclap.com/events/ISS24STARTING</a></p></td>
</tr>
<tr class="row-even"><td><p>GITHUB del corso</p></td>
<td><p><a class="reference external" href="https://github.com/anatali/issLab24">https://github.com/anatali/issLab24</a></p></td>
</tr>
<tr class="row-odd"><td><p>Lezioni svolte</p></td>
<td><p><a class="reference external" href="https://anatali.github.io/issLab24/iss24Material/LectureBologna2024.html">https://anatali.github.io/issLab24/iss24Material/LectureBologna2024.html</a></p></td>
</tr>
</tbody>
</table>
<p><span class="slide1">1) IL CORSO 2024</span></p>
</section>
<section id="promesse-del-corso">
<h2>Promesse del corso<a class="headerlink" href="#promesse-del-corso" title="Permalink to this heading">¶</a></h2>
<p>Riportiamo qui quanto si legge nel <a class="reference external" href="https://www.unibo.it/it/didattica/insegnamenti/insegnamento/2023/468003">Sito Web del corso</a>  -&gt;:</p>
<p>Al termine del corso lo studente:</p>
<ul class="simple">
<li><p>è in grado di impostare <span class="blue">processi di sviluppo cooperativo</span> del software basati su approcci agili
(in particolare SCRUM) avvalendosi anche di modelli eseguibili, espressi mediante meta-modelli custom;</p></li>
<li><p>è’ in grado di progettare e sviluppare sistemi software e relativi piani di testing in modo <span class="blue">incrementale
ed evolutivo</span>, partendo dal problema e dal dominio applicativo piuttosto che dalla tecnologia realizzativa,
attraverso la definizione di modelli eseguibili dell’<span class="blue">analisi dei requisiti e dell’analisi del problema</span>;</p></li>
<li><p>è in grado di <span class="blue">valutare in modo critico</span> le continua evoluzione delle tecnologie informatiche,
sia a livello computazionale, sia livello di sviluppo-software, acquisendo <span class="blue">conoscenze teorico-operative</span>
su linguaggi, metododologie e strumenti quali <em>Kotlin, Gradle, SCRUM, SpringBoot, Docker</em>;</p></li>
<li><p>è in grado di comprendere il ruolo dei diversi <span class="blue">stili di architetture software</span>
(layers, client-server, pipeline, microkernel, service-based, event-driven, space-based, microservices)
e di come <span class="blue">scegliere lo stile architetturale più opportuno</span> per i diversi sotto-sistemi individuati;</p></li>
<li><p>è in grado di affrontare l’analisi, il progetto e la costruzione di applicazioni distribuite ed eterogenee
di tipo proattivo e/o reattivo (unitamente a loro possibili piattaforme di sviluppo e di supporto run-time)
con particolare riferimento a <span class="blue">modelli computazionali a scambio di messaggi e ad eventi</span>;</p></li>
<li><p>è in grado di realizzare le <span class="blue">interazioni a scambio di messaggi</span> tra componenti distribuiti utilizzando
modelli logici di alto livello e implementazioni basate su protocolli diversi (TCP, UDP, HTTP, CoAP, MQTT);</p></li>
<li><p>è in grado di comprendere come sia possibile progettare e costruire ambienti di sviluppo custom capaci
di <span class="blue">generazione automatica di codice</span> (Software Factories in ‘ecosistemi’ come Eclipse/IntelliJ),
basandosi su <em>Model Driven Software Development</em> (MDSD) e sull’uso di Domain Specific Languages (DSL);</p></li>
<li><p>è in grado di sviluppare applicazioni <span class="blue">capaci di combinare</span> aspetti di alto livello (in particolare di AI)
con aspetti di basso livello relativi a dispositivi di Internet of Things (IOT), utilizzando sia ambienti
virtuali sia dispositivi reali costruibili utilizzando elaboratori a basso costo quali RaspberryPi e Arduino;</p></li>
<li><p>è in grado di <span class="blue">applicare</span> i concetti, i dispositivi, e gli strumenti sviluppati in modo concreto ed operativo
durante il corso per lo sviluppo di una <span class="blue">applicazione finale</span> che utilizza uno o più dispositivi IOT ‘situati’,
con particolare riferimento a <em>Differental Drive Robots</em> (DDR) con sensori
che possono agire in modo relativamente autonomo in <span class="blue">diversi</span> ambienti virtuali o reali,
senza modificare il software che esprime la ‘business logic’ del problema.</p></li>
</ul>
<p><span class="slide1">2) Il nostro metodo di lavoro</span></p>
<section id="il-metodo-di-lavoro">
<h3>Il metodo di lavoro<a class="headerlink" href="#il-metodo-di-lavoro" title="Permalink to this heading">¶</a></h3>
<ol class="arabic">
<li><p>Partiamo dall’insieme di requisiti <strong>forniti dal committente</strong> ed espressi in linguaggio naturale</p></li>
<li><p>Impostiamo lo <code class="docutils literal notranslate"><span class="pre">SPRINT0</span></code> come una <strong>analisi dei requisiti</strong> che mira a esprimerli in modo comprensibile anche alla macchina introducendo:</p>
<ul class="simple">
<li><p>un modello (eseguibile) dell’architattura del sistema desunta dai requisiti</p></li>
<li><p>un (primo) insieme di piani di test funzionali</p></li>
</ul>
</li>
<li><p>Impostiamo una <strong>analisi del problema</strong> che mira a definire:</p>
<ul class="simple">
<li><p>una architettura logica del sistema come risultato dall’analisi</p></li>
<li><p>un piano di lavoro</p></li>
<li><p>una possibile estensione ai piani di testing</p></li>
<li><p>la definizione del primo SPRINT relizzativo</p></li>
</ul>
</li>
<li><p>Impostiamo ogni SPRINT come un <strong>sottoprogetto</strong> con sua propria spiegazione e testing.</p>
<ul class="simple">
<li><p>Lo SPRINT <span class="math notranslate nohighlight">\(n+1\)</span> parte dai risultati dello sprint <span class="math notranslate nohighlight">\(n\)</span> e costruisce un sottosistema (funzionante)
che sarà l’input dello SPRINT <span class="math notranslate nohighlight">\(n+2\)</span>.</p></li>
</ul>
</li>
<li><p>Facciamo seguire ad ogni SPRINT una fase di <a class="reference external" href="https://www.agileway.it/sprint-review-meeting/">Sprint review</a> -&gt; i cui meeting saranno</p>
<ul class="simple">
<li><p><span class="remark">un nuovo modo di concepire le ore di ricevimento-studenti</span>.</p></li>
</ul>
</li>
<li><p>Per ogni  SPRINT, compiliamo un documento (si veda <span class="xref std std-ref">template2024</span>)  per <span class="blue">rendere esplcite</span> le conoscenze,
le decisioni, i modelli, etc. introdotti nello SPRINT,
fornendo indicazioni all’utente finale su come eseguire lo SPRINT.</p>
<p><span class="slidekp">Il template come diario di bordo</span></p>
<p><span class="xref std std-ref">Il template</span> va inteso come un <span class="remark">logbook</span> (<em>diario di bordo</em>), da compilare <strong>in itinere</strong>
con indicazioni <strong>sintetiche ed essenziali</strong>, man mano si svolge
il processo di produzione e <span class="brown">non dopo</span> avere sviluppato il codice.</p>
</li>
</ol>
<p><span class="slide1">3) Fasi del corso</span></p>
</section>
<section id="fasi-del-corso">
<h3>Fasi del corso<a class="headerlink" href="#fasi-del-corso" title="Permalink to this heading">¶</a></h3>
<ol class="arabic">
<li><p>Dalla OOP ai sistemi a scambio di messaggi come programmatori che devono utilizzare un (micro) servizio.
Il servizio è un sistema software di cui occcorre consosce la <a class="reference internal" href="Intro2024.html#vista-esterna"><span class="std std-ref">Vista esterna</span></a>.
Si veda <a class="reference internal" href="#per-iniziare"><span class="std std-ref">Per iniziare</span></a>.</p></li>
<li><p>Da programmatori-utilizzatori a progettesti-costruttori del (micro) servizio.
Il servizio è un sistema software di cui si affronta lo sviluppo della sua
<a class="reference internal" href="Intro2024.html#vista-interna"><span class="std std-ref">Vista interna</span></a></p>
<p>In questa fase:</p>
<ul class="simple">
<li><p>viene introdotto un linguaggio custom ad attori per lo sviluppo incrementale di prototipi, a partire da un insieme di requisiti;</p></li>
<li><p>viene sperimentato il ruolo dei modelli esguibili nella costruizione incrementale del software;</p></li>
<li><p>viene approfondito un criterio / metodo di sviluppo top-down secondo il motto, che imposta il processo di progettazione
e produzione sulle premesse dei modelli definiti nella fase di analisi.</p></li>
</ul>
</li>
<li><p>Progetto e sviluppo di un sistema che realizza il gioco <a class="reference external" href="https://it.wikipedia.org/wiki/Gioco_della_vita">Conway Life</a> -&gt; come sistema distribuito
(si veda anche <a class="reference external" href="https://playgameoflife.com/">Conway Life play</a> -&gt;).</p></li>
<li><p>Progetto e sviluppo di un sistema distribuito  nel campo delle <strong>applicazioni IOT</strong>,
che prevede  l’utilizzo di robot virtuali e/o <a class="reference external" href="_static/devsDdr.html">robot reali</a>,</p></li>
</ol>
<blockquote>
<div><a class="reference internal image-reference" href="_images/mbotIot.png"><img alt="_images/mbotIot.png" class="align-center" src="_images/mbotIot.png" style="width: 70%;" /></a>
</div></blockquote>
</section>
<section id="per-iniziare">
<h3>Per iniziare<a class="headerlink" href="#per-iniziare" title="Permalink to this heading">¶</a></h3>
<p>Il servizio (implementato in Java) può essere attivato in due modi:</p>
<ol class="arabic simple">
<li><p>eseguendo il file batch <code class="docutils literal notranslate"><span class="pre">unibo.servicemath.bat</span></code> (su windows) o <code class="docutils literal notranslate"><span class="pre">unibo.servicemath</span></code> (su Linux)
estratto dal file di distribuzione del prodotto (<strong>servicemath24Asynch-1.0.zip</strong>).</p></li>
</ol>
<blockquote>
<div></div></blockquote>
<ol class="arabic">
<li><p>eseguendo il comando docker: <strong>docker-compose</strong>  <a class="reference external" href="./_static/code/servicemathAsynch.yaml">servicemathAsynch.yaml</a>.</p>
<p>Una volta attivato, il servizio fornisce una pagina HTML, accessibile mediante browser alla porta <code class="docutils literal notranslate"><span class="pre">8088</span></code>:</p>
<blockquote>
<div><a class="reference internal image-reference" href="_images/servicefacade24_1.PNG"><img alt="_images/servicefacade24_1.PNG" class="align-center" src="_images/servicefacade24_1.PNG" style="width: 50%;" /></a>
</div></blockquote>
</li>
</ol>
<section id="da-fare-sul-proprio-pc">
<h4>Da fare sul proprio PC<a class="headerlink" href="#da-fare-sul-proprio-pc" title="Permalink to this heading">¶</a></h4>
<ol class="arabic simple">
<li><p>Installare <span class="blue">Java JDK 11</span>  (non useremo versioni più recenti)</p></li>
<li><p>Installare <span class="blue">GIT</span> <span class="brown">PERSONALE PRIVATO</span> e <strong>dare accesso al docente</strong></p></li>
<li><p>Compilare il <a class="reference external" href="_static/templateToFill.html">template</a> inserendo <strong>fotografia, email e numero di matricola</strong></p></li>
<li><p>Clonare <a class="reference external" href="https://github.com/anatali/issLab24">https://github.com/anatali/issLab24</a> in una directory vuota e.g. <code class="docutils literal notranslate"><span class="pre">C:/.../issLab24</span></code></p></li>
<li><p>Installare <span class="blue">Gradle</span>  (8.6 o 7.6)  (per <em>System Properties Advanced</em> su Windows: <code class="docutils literal notranslate"><span class="pre">sysdm.cpl</span></code>)</p></li>
<li><p>Installare  <span class="blue">Eclipse IDE</span>: <a class="reference external" href="https://www.eclipse.org/downloads/packages/">Eclipse IDE for Java and DSL Developers</a> (2023 12)</p></li>
<li><p>Installare <span class="blue">IntelliJ</span></p></li>
<li><p>Installare <span class="blue">Docker</span></p></li>
<li><p>Installare <span class="blue">Node.js</span></p></li>
<li><p>Installare <span class="blue">Python (3.8.8)</span></p></li>
</ol>
<p><span class="slide1">4) Cosa si valuta</span></p>
</section>
</section>
</section>
<section id="criteri-di-valutazione">
<h2>Criteri di valutazione<a class="headerlink" href="#criteri-di-valutazione" title="Permalink to this heading">¶</a></h2>
<ol class="arabic simple">
<li><p>La costruzione di un prototipo di sistema software che soddisfa l’insieme di requisiti dato nel <span class="xref std std-ref">Temafinale</span>,
mira a verificare il raggiungimento di adeguate abilità teorico/pratiche
e può essere effettuata in <span class="remark">modo individuale</span> oppure in un <span class="remark">gruppo di non più di tre studenti</span>.</p></li>
<li><p>La discussione individuale orale che segue la demo del prototipo è volta a valutare
<span class="blue">il livello di conoscenza, consapevolezza e di autonomia analitico/progettuale</span> <span class="remark">del singolo studente</span>.</p></li>
</ol>
<section id="dettagli-sul-colloquio-orale">
<h3>Dettagli sul colloquio orale<a class="headerlink" href="#dettagli-sul-colloquio-orale" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>48 h prima del colloqio, il codice del sistema finale deve essere stato pubblicato sul sito del prototipo
(individuale o di gruppo),
dandone relativa informazione via mail al docente.</p></li>
<li><p>Il giorno del colloquio, ogni gruppo deve avere effettuato gli opportuni preparativi per la/le demo,
in modo da essere subito operativo.</p></li>
</ul>
<p>L’ordine di presentazione dei gruppi verrà opportunamente stabilito dal docente e si svolgerà come qui di seguito
indicato.</p>
<ol class="arabic simple">
<li><p>Presentazione (collettiva di gruppo) di una <span class="slide1">demo ‘live’ del sistema finale</span> di durata 10-15(max) minuti.
La demo deve mostrare la esecuzione di almeno un Test(Plan) automatizzato ritenuto significativo.
Per applicazioni che NON usano robot reali NON sono ammessi video,
che potrebbero essere invece utili per mostrare il funzionamento di robot reali
o di sistemi che includono il RaspberryPi o altri dispositivi</p></li>
<li><p>Presentazione (collettiva di gruppo) del progetto del sistema e della sua relazione
con la fase di analisi. In questa fase è RICHIESTA la preparazione di
<span class="slide1">5-7 SLIDES  di illustrazione del processo e dell’architettura finale</span> con figure e (se ritenuto utile) riferimenti al codice.
Al termine di queste fasi il gruppo può raggiungere un <span class="remark">punteggio massimo di 27/30</span>.</p></li>
<li><p>Domande (per esempi, si veda qui sotto) rivolte dal docente a singole persone,
riguardo al prodotto, al progetto e alla analisi del problema/requisiti.
Al termine di questa fase, il singolo studente può raggiungere un <span class="remark">punteggio massimo di 29/30</span>.</p></li>
<li><p>Altre domande rivolte dal docente a singole persone. Al termine di questa fase, il singolo studente
può raggiungere il <span class="remark">punteggio di 30 e lode</span>.</p></li>
</ol>
</section>
</section>
<section id="note-dopo-le-interazioni-con-gli-studenti">
<h2>Note dopo le interazioni con gli studenti<a class="headerlink" href="#note-dopo-le-interazioni-con-gli-studenti" title="Permalink to this heading">¶</a></h2>
<ol class="arabic simple">
<li><p>Lo scopo del tema finale NON è (solo) risolvere il problema ma avere un <span class="blue">caso di studio su cui ragionare sul
processo di costruzione del software</span>.</p></li>
<li><p>L’uso del linguaggio <strong>qak</strong> non va preso come un vincolo a priori.
Ne va invece motivato l’uso (come per ogni altra tecnologia) in relazione alle caratteristiche del (sotto)problema esaminato.
Poichè il lettore potrebbe non consoscere questo linguaggio, è opportuno scrivere - una volta sola - un
(breve) documento che spiega per quali caratteristiche si ritiene opportuno usare i qak.
Il documento dovrebbe porre in luce gli aspetti salienti, rinviando (con links) gli approfondimenti ai documenti ‘ufficiali’,
in modo da porre in evidenza il perchè lo si propone, nel contesto del problema.</p></li>
<li><p>I link tra i vari documenti dovrebbero essere possibilmente locali, in modo da poter leggere i documenti stessi senza
(ove possibile) connessione di rete.</p></li>
<li><p>Lo <span class="blue">scopo della analisi dei requisiti</span> è ridefinire il testo dato dal committente in modo ‘preciso’ (e formale, cioè
per noi, comprensibile alla macchina). Per le varie entità menzionate nel testo, occorre dare risposta ad alcune
precise domande, tra cui (altri tipi di domande sarebbe bene fossero individuate da voi):</p>
<ul class="simple">
<li><p>cosa intende il committente per xxx (ad esempio DDR robot, Virtual Robot)?</p></li>
<li><p>il committenete fornisce indicazioni sul software da usare per xxx?</p></li>
<li><p>se si, è possibile fornire un modello di tale software (per capire bene cosa bisogna sapere per usarlo)?</p></li>
</ul>
</li>
</ol>
<blockquote>
<div><p>Si tenga conto di quanto detto in :ref:``</p>
</div></blockquote>
<ol class="arabic simple">
<li><p>Occorre anche porre molta attenzione alle frasi scritte in linguaggio naturale e dare loro una interpretazione
non ambigua. Ad esempio:</p>
<ul class="simple">
<li><p>per la frase <em>a DDR robot working as a transport trolley</em>, che relazione si pensa debba esistere tra
l’entità <em>trolley</em> e l’entità <em>DDR robot</em>?</p></li>
</ul>
</li>
<li><p>Ogni fase (a partire dai requisiti) dovrebbe terminare con la specifica di un modello (anche non eseguibile)
che costituisce l’inizio della fase successiva.  Al modello dovrebbe essere associato un insieme di TestPlan
(ne basta anche solo uno signficativo) di tipo funzionale per chiarire cosa ci si aspetta (come ouput) dal software
che <em>dovrà essere sviluppato per quel requisito</em>, una volta date le opportune info di ingresso.</p></li>
<li><p>Ogni modello dovrebbe essere accompagnato da almeno un TestPlan funzionale significativo.</p></li>
<li><p>Lo <span class="blue">scopo della fase di analisi del problema</span> è definire una modello (eseguibile) della architettura logica e
dare elementi utili per la costruzione di un <em>piano di lavoro</em> e per la <span class="blue">suddivsione dei compiti</span> tra i componenti
del Team.</p></li>
<li><p>Il primo SPRINT dovrebbe scaturire dal piano di lavoro e iniziare a partire dal modello dell’analisi</p></li>
<li><p>Ogni SPRINT dovrebbe:</p>
<ul class="simple">
<li><p>essere associato a un preciso obiettivo (SCRUM goal)</p></li>
<li><p>approfondire l’analisi relativa al sottoproblema relativo al goal dello SPRINT</p></li>
<li><p>estendere/precisare l’architettura logica e i TestPlan</p></li>
<li><p>definire una architettura di progetto e Test relativi</p></li>
<li><p>terminare con un prototipo eseguibile (da discutere con il committente)  e una proposta di nuovo SPRINT
(che potrebbe anche consistere in una revisione dell’analisi, se si vede che è stata fatta male)</p></li>
</ul>
</li>
<li><p>Ogni SPRINT dovrebbe <span class="blue">terminare con una pagina di sintesi</span> che riporta l’architettura finale
del sistema (con i link al modello e ai Test).
Questa pagina sarà l’inizio del documento relativo allo SPRINT successivo.
E’ opportuno anche inserire istruzioni su come eseguire il software sviluppato, ad uso dell’utente finale.</p></li>
</ol>
<section id="come-organizzare-gli-sprint">
<h3>Come organizzare gli sprint<a class="headerlink" href="#come-organizzare-gli-sprint" title="Permalink to this heading">¶</a></h3>
<p>Lo scopo dello SPRINT0 dovrebbe essere quello di formalizzare i singoli termini del testo
(usando un qualche linguaggio di programmazione e/o con modelli) e anche quello di fornire  una prima visione
di insieme del sistema da realizzare.</p>
<p>Lo SPRINT0 dovrebbe concludersi fornendo un modello delle macro-parti del sistema,
evidenziando quali componenti sono forniti dal committente (ad esempio DDRrobot, Sonar, etc.) e quelli che invece
bisogna sviluppare.
I  messaggi che questi componenti si scambiano potrebbero essere veri e propri requisiti ma anche <em>solo indicativi</em>
di chi dovrà inviare informazione e di chi dovrà riceverla.</p>
<p>Ad esempio, si potrebbe introdurre un modello come quello che segue:</p>
<blockquote>
<div><a class="reference internal image-reference" href="_images/sprint0.png"><img alt="_images/sprint0.png" class="align-center" src="_images/sprint0.png" style="width: 75%;" /></a>
</div></blockquote>
<p>Questa immagine viene generata in modo automatico da un  MODELLO Qak che può essere scritto
in pochi minuti, per CATTURARE GLI ASPETTI RITENUTI ESSENZIALI
(e certo - almeno per ora - non perchè sia eseguibile).</p>
<p>Lo scopo di questo modello è di costituire un <span class="blue">SISTEMA LOGICO  DI RIFERIMENTO</span> e di evidenziare che:</p>
<ul class="simple">
<li><p>Il sistema è distribuito su almeno 3 nodi computazionali diversi (il <em>driver</em> è un simulatore).</p></li>
<li><p>Saremo chiamati a sviluppare i macro-componenti  <em>wasteservice, transporttrolley, sonaronrasp, wastewervicewtatusgui</em>.</p></li>
<li><p>La interazione <em>driver-wasteservice</em> è di tipo request-response ed è implicata dal testo dei requsiti.</p></li>
<li><p>La interazione <em>sonaronrasp-transporttrolley</em> è modellata come un evento, ma non è un requisito. Dunque potrebbe essere
modificata negli sviluppi successivi, mentre potrebbe essere ritenuto un requisito che l’informazione prodotta dal
sottosistema su <em>ctxrasp</em> non sia di pertinenza del <em>wasteservice</em> (cosa questa da discutere e da approfondire con
il committente).</p></li>
<li><p>Risulta invece un requisito architetturale il fatto che il <em>wasteservice</em> ‘non vede’ il <em>basicrobot</em>
(che è un componente dato dal committente).</p></li>
</ul>
<p>Questo modello dovrebbe fornire il quadro architetturale complessivo dal quale dedurre
un possibile piano di lavoro che conduce allo SPRINT1.</p>
<p>Ad esempio, se il team e il committente concordano sulla opportunità di affrontare in primis il
<strong>core-business</strong> del problema, allora
lo SPRINT1 potrebbe escludere di trattare la GUI  e la parte su Rasp (se non in modo astratto
o simulato) e avere come <span class="blue">GOAL</span> (si veda SCRUM) quello di fornire un primo prototipo
che realizza le funzionalità fondamentali del sistema.</p>
<p>Lo SPRINT1  (come ogni altro sprint in futuro) dovrebbe quindi affrontare un
<span class="blue">preciso sottoinsieme dei requisiti</span>, che va individuato  ed associato a uno o più Test-plan funzionali.</p>
<p>Nel caso specifico, si tatta di analizzare il problema della interazione <em>wasteservice-transporttrolley-basicrobot</em>
a partire dalla richiesta del driver.</p>
<p>Ogni sprint deve quindi fare uno <span class="blue">ZOOMING</span> entro una parte della architettura di RIFERIMENTO,
analizzando le problematiche poste dal sottoinsieme dei requisiti considerato. Ad esempio
l’analista di questo SPRINT1 potrebbe :</p>
<ul class="simple">
<li><p>affrontarre il problema di quando sia opportuno rispondere al driver,</p></li>
<li><p>discutere su chi abbia la responsabilità di muovere il <em>transporttrolley</em> (il <em>wasteservice</em>, inviando
(macro) comandi o il <em>transporttrolley stesso</em> ),</p></li>
<li><p>studiate il problema di chi debba aggiornare la gui e quando</p></li>
<li><p>etc. etc.</p></li>
</ul>
<p>Alla fine della analisi del problema, il modello di riferimento avrà subito una <span class="blue">evoluzione</span> che fornisce
una una <span class="blue">nuova architattura logica</span>, che sarà il punto di partenza per un nuovo piano di lavoro.
Infatti sia l’analista prima che il progettista poi, potrebbero precisare la natura di alcune interazioni e
introdurre nuovi componenti all’interno di <em>ctxwasteservice</em>.</p>
<p>Sottolineiamo che, al termine dello SPRINT,
un componente ptrebbe anche essere realizzato non come un QAk actor.
Ad esempio,   la <em>WasteServiceStatusGUI</em>  potrebbe essere realizzata come web-application.
Il componente QAk che definisce la logica di <em>wastewervicewtatusgui</em> potrebbe essere ‘dimenticato’
o (forse, preferibilmente) <span class="blue">riusato</span> all’interno di questa web-application.</p>
</section>
</section>
<section id="esempi-di-possibili-domande-finali">
<h2>Esempi di possibili domande finali<a class="headerlink" href="#esempi-di-possibili-domande-finali" title="Permalink to this heading">¶</a></h2>
<p>Riportiamo qui un elenco di possibili domande finali durante i colloqui orali:</p>
<ul class="simple">
<li><p>Abbiamo appena visto il funzionamento della applicazione. Possiamo vedere il progetto?
Quale rappresentazione (linguaggio naturale, diagrammi UML, modelli, figure, parti di codice, …)
propone per l’esposizione del progetto?</p></li>
<li><p>Che forma assume il deliverable di progetto e come è stato prodotto?
Vi sono connessioni cone la fase di analisi del problema? E con la fase di analisi dei requisiti?</p></li>
<li><p>Come ci può convincere che l’applicazione ‘copre’ tutti i requisiti dati senza doverla eseguire
caso per caso?</p></li>
<li><p>Può mostrare la struttura della architettura finale del sistema?
In quale forma ritiene sia più opportuno presentare l’architettura (o in generale una architettura software)
per poterne discutere in modo pragmaticamente utile (cioè non solo in modo vago e discorsivo)?</p></li>
<li><p>L’architettura finale è’ stata preceduta dalla definizione di una archittura logica scaturita
come deliverable della fase di analisi del problema?</p></li>
<li><p>Quali sono i punti salienti che sono stati posti in luce nella fase di analisi del problema?
E’ stato evidenziato qualche punto particolamente critico?</p></li>
<li><p>Quali sono i <span class="xref std std-ref">principi</span> su cui si  basata la progettazione del sowftware?</p></li>
<li><p>E’ possibile, secondo lei, definire un modello eseguibile del sistema già al termine della fase di
analisi dei requisiti? Se sì, quali vantaggi se ne potrebbero trarre?
Se no, perchè non lo ritiene possibile?</p></li>
<li><p>Immagino che come linguaggio di codifica si sia usato principlamente Java e/o Kotlin,
insieme a qualche parte scritta in C, C++, Python, JavaScript, etc).
Nella fase di analisi del problema, è stato evidenziato qualche macroscopico gap rispetto queste tecnologie?
Se sì’ come si è pensato di colmare questo ‘abstraction gap’?</p></li>
<li><p>Fino a che punto è utile introdurre diagrammmi <code class="docutils literal notranslate"><span class="pre">UML</span></code> e per quali scopi?
Quali sono le motivazioni che possono indurre una software-house a definire linguaggi
(o metamodelli) Domain-specific?</p></li>
<li><p>In ambiente industriale non è possibile pensare che sia possibile utilizzare il metamodello <code class="docutils literal notranslate"><span class="pre">QActor</span></code>.
Ma di certo è diffuso l’uso delle librerie. Secondo lei sarebbe possibile affrontare lo sviluppo
di applicazioni distribuite usando solo la libreria <code class="docutils literal notranslate"><span class="pre">it.unibo.qakactor-x.y.jar</span></code> e quelle ad essa necessarie?</p></li>
<li><p>Ha trovato un qualche vantaggio nell’uso dei <code class="docutils literal notranslate"><span class="pre">QActor</span></code> attraverso un linguaggio custom (di ispirazione <code class="docutils literal notranslate"><span class="pre">DSL</span></code>)
dotato di un suo proprio IDE? Ha una idea di come sia stato prodotto l’IDE per i QActor in ambiente Eclipse?</p></li>
<li><p>Le mostro l’architettura logica proposta dal gruppo xyz. Trova questa architettura logica concordante
con la sua o è possibile evidenziare macroscopiche differenze?.
Se nota differenze, le possiamo tollerare o no?</p></li>
<li><p>In quale fase (analisi, progetto,…) è stata decisa la natura software dei componenti del sistema;
quali sono le motivazioni per queste scelte, e dove sono riportate/discusse?</p></li>
<li><p>In quale fase (analisi, progetto,…) è stata decisa la interazione tra i componenti del sistema;
quali sono le motivazioni per queste scelte, e dove sono riportate/discusse?</p></li>
<li><p>In quale fase dello sviluppo è stata definita una pianificazione dei lavori e una loro ripartizione
tra i componenti del team?</p></li>
<li><p>In quanti Sprint Scrum-like si è svolto lo sviluppo del software?</p></li>
<li><p>Durante la fase di sviluppo, è stato necessario rivedere qualche parte della analisi del problema?
In altre parole, sono state trovate situazioni che l’analista non aveva previsto o aveva affrontato
in modo incompleto? Se sì, ha qualche esempio? E come si è procduto in questo caso?</p></li>
<li><p>E’ possibilie sapere, per ciascun componente del team, di quali aspetti del sistema si è
specificatamente occupato? Quando sono state definite e da chi queste ripartizioni dello sviluppo?</p></li>
<li><p>In quale fase dello sviluppo sono stati impostati programmi per il testing?
Quali tipi di test (unit, integration, …) sono stati pensati e quali effettivamente realizzati?</p></li>
<li><p>L’architettura finale del sistema mostra qualche pattern architetturale riconoscibile
(ad es. client-server, layer, clean …) e in quale fase dello sviluppo (analisi/progetto)
è stato deciso di introdurlo? E perchè? Queste motivazioni sono riportate/discusse in qualche documento?</p></li>
<li><p>E’ possibile utilizzare l’applicazione avvalendosi di un Browser? Se no, per quale motivo
si e’ esclusa questa possibilità?</p></li>
<li><p>Come è stato affrontato il requisito xyz?</p></li>
<li><p>Come viene rappresentato lo stato del sistema?
E’ uno stato ‘concentrato’, cioè gestito da un solo componente o distribuito tra più componenti?
Chi e quando ha preso una decisione in merito a questo punto?</p></li>
<li><p>Il sistema finale utilizza solo un DDR virtuale. Cosa bisognerebbe fare per utilizzare un robot fisico
e quanto tempo sarebbe necessario per il refactoring del sistema?</p></li>
<li><p>Il sistema finale e’ stato sviluppato tenendo conto dei principi SOLID? E’ possibile vederne qualche esempio?</p></li>
<li><p>E’ stato utilizzato il linguaggio Prolog? Se sì, per quale motivo?</p></li>
<li><p>Sono state utilizzate annotazioni Java? Se sì, in quali parti o in quali funzionalità e per quale motivo?</p></li>
<li><p>Per un eventuale supporto Web, quale framework è stato utilizzato? Spring o Node/Express? Quali sono le motivazioni della scelta?</p></li>
<li><p>Il sistema finale coinvolge anche un RasperryPi?
Se si, quale parte del sistema è stato deployed sul Rasp e in quale modo?</p></li>
<li><p>E’ stato tentato un deplyoment della applicazione (o di parti di essa) utilizzando docker?
E docker-compose? Se sì quali sono i criteri/motivazioni per la ripartizione di parti applicative su docker?</p></li>
</ul>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">ISS2024</a><ul>
<li><a class="reference internal" href="#intro2024-indice">Intro2024 indice</a></li>
<li><a class="reference internal" href="#promesse-del-corso">Promesse del corso</a><ul>
<li><a class="reference internal" href="#il-metodo-di-lavoro">Il metodo di lavoro</a></li>
<li><a class="reference internal" href="#fasi-del-corso">Fasi del corso</a></li>
<li><a class="reference internal" href="#per-iniziare">Per iniziare</a><ul>
<li><a class="reference internal" href="#da-fare-sul-proprio-pc">Da fare sul proprio PC</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#criteri-di-valutazione">Criteri di valutazione</a><ul>
<li><a class="reference internal" href="#dettagli-sul-colloquio-orale">Dettagli sul colloquio orale</a></li>
</ul>
</li>
<li><a class="reference internal" href="#note-dopo-le-interazioni-con-gli-studenti">Note dopo le interazioni con gli studenti</a><ul>
<li><a class="reference internal" href="#come-organizzare-gli-sprint">Come organizzare gli sprint</a></li>
</ul>
</li>
<li><a class="reference internal" href="#esempi-di-possibili-domande-finali">Esempi di possibili domande finali</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="Intro2024.html"
                          title="previous chapter">Intro2024</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="QakService24Usage.html"
                          title="next chapter">QakService24Usage</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/ISS2024.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="QakService24Usage.html" title="QakService24Usage"
             >next</a> |</li>
        <li class="right" >
          <a href="Intro2024.html" title="Intro2024"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">iss24 1.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ISS2024</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2024, Antonio Natali.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.0.2.
    </div>
  </body>
</html>