System /*-msglog  -trace */ servicemathmemo  
//mqttBroker "broker.hivemq.com" : 1883 eventTopic "servicetopic"

//Messages for the application 
Request dofibo   : dofibo(N)
Reply   fibodone : fibodone( CALLER,N,RESULT,TIME ) for dofibo
 
//Messages for the display 
Dispatch out  : out(S) 
Dispatch show  : show(S)         

//Messages for storage
Request getfibo : getfibo(N)
Reply   getfiboanswer : getfiboanswer(N,V) for getfibo //LAST=0 => V=fibo(N) else V=fibo(LAST)



/*
 * Il servizio arriva fino a un valore di 9223372036854775807
 * che implica 0 <= n <= 92
 */
Context ctxservice ip [host="localhost" port=8011]  

/* 
QActor display context ctxservice {  //withobj d using "utils.DisplayObj.create()"
 	State s0 initial{		
	}
	Transition t0 whenMsg out  -> view
	              whenMsg show -> view
	
	State view{
		printCurrentMessage color yellow
		[# val SOUT = "${currentMsg.msgContent()}" #] //inizia con out o con show
		println("$name | $SOUT ") color yellow
		updateResource [# "$SOUT" #]
	} 
	Transition t0 whenMsg out  -> view
	              whenMsg show -> view

}
*/

/*
 */
 
QActor caller context ctxservice {  
	[#  var SOUT = ""
	#] 
 	State init initial { 
  		delay 6000
		[# SOUT = "$name | starts"  #]
//		forward display -m out : out($SOUT)
 		request servicemath -m dofibo : dofibo(43)
 		delay 500
 		request servicemath -m dofibo : dofibo(93)
	}	 
	Transition t0 whenReply fibodone -> fiboanswer
	
	State fiboanswer{
		printCurrentMessage color magenta
		onMsg(fibodone : fibodone( CALLER,V,R,T) ){
			[# SOUT = "$name | fiboanswer for ${payloadArg(1)} from ${payloadArg(0)}=${payloadArg(2)} time=${payloadArg(3)}" #]
//            forward display -m out : out($SOUT)
		}   
	}
	Transition t0 whenReply fibodone -> fiboanswer
}


QActor storage context ctxservice withobj math using "MathUtils.create()"{	 
		[# val engine = Prolog()
			
		#]
	State s0 initial { 
		
		
		[# var N = 5 #] 

		println("$name | STARTS ") color green

		//CALCOLO LUNGO SENZA LONG
//        [# val T00 = getCurrentTime() #]
//		[# val R46_0 = math!!.fibo( 46  ) #]
//		[# val T0F  = getDuration(T00)  #]
//		println("$name | R46_0=$R46_0 time=$T0F") color green	

		
		//[# sysUtil.loadTheory("storage.pl") #]
		[# math!!.loadTheory("storage.pl", engine) #]
		//[# math!!.saveTheory("xxx0.pl", engine )  #]
		
		//VERIFICO CHE ESISTE fibo(N, ...)
		[# val V = math!!.solve("fibo($N,V)","V",engine) #]
		println("$name | V=$V ") color green	
//		[# val V10 = math.fibo(10,5,8) #]
//		println("$name | V10=$V10 ") color green
//		[# val V15 = math.fibo(15,5,8) #]
//		println("$name | V15=$V15 ") color green
/* 
        [# 
        	val VX5 = math!!.fibo(5)
        #]
        println("$name | VX5=$VX5 ") color green
        
		[#  //CONOSCO
			val V4 = Pair<Int,Int>(4,3)
			val V5 = Pair<Int,Int>(5,5)
			//CALCOLO fibo(7)
			val V7 = math!!.fibo2(7,V5,V4)  //safe call			
			val fact = "fibo(7,${V7.second})"
			//MEMORIZZO
			val R    = math!!.solve("assert("+ fact +")","", engine)
			
			//CALCOLO fibo3(9) 
			val P1   = math!!.fibo3( 9 )
			val P1a  = "fibo(9,${P1.first})"
			val P1b  = "fibo(8,${P1.second})"
			math!!.solve("assert("+ P1a +")","", engine)
			math!!.solve("assert("+ P1b +")","", engine)
			
		#]
		println("$name | V7=$V7 R=$R  ${P1.first}|${P1.second}") color green
		[# val V8 = math!!.solve("fibo(8,X)","X", engine) #]
		println("$name | V8=$V8 ") color green	

		//CERCO fibo(12
		[# val V12 = math!!.solve("fibo(12,X)","X", engine) #]
		println("$name | V12=$V12 ") color green	
*/ 
        //CALCOLO fibo4(45) 
//        [# val T0 = getCurrentTime() #]
//		[# val R45 = math!!.fibo4( 45,engine ) #]
//		[# val TF  = getDuration(T0)  #]
//		println("$name | R45=$R45 time=$TF") color green	

        //CALCOLO fiboWithMemo(46) 
//        [# val T0 = getCurrentTime() #]
//		[# val R46 = math!!.fiboWithMemo( 46L,engine ) #]
//		[# val TF  = getDuration(T0)  #]
//		println("$name | R46=$R46 time=$TF") color green	

        //CERCO NMAX
//        [# val T1 = getCurrentTime() #]
//        [# val K = 93L #]
//		[# val R  = math!!.fiboWithMemo( K,engine ) #]
//		[# val TF1  = getDuration(T1)  #]
//		println("$name | K=$K R=$R time=$TF1") color green	
//
//        //LISTA DEI VALORI MEMORIZZATI
//		[# val NUMS = math!!.solve("storednums(X)","X", engine) #]
//		println("$name | NUMS=$NUMS ") color green	
//		
//		//MASSIMO VALORE DI FIB CALCOLATO
//		[# val NMax = math!!.solve("maxnumstored(X)","X", engine) #]
//		println("$name | NMax=$NMax ") color green	
		
//		[# math.saveTheory("xxx.pl", engine) #]

	}	
	Transition t0 whenRequest getfibo -> elab
	
	State elab{
		onMsg( getfibo : getfibo(N) ){
			[# val K = payloadArg(0).toLong() 
			   val R = math!!.fiboWithMemo( K,engine )
			   
			#]
			replyTo getfibo with getfiboanswer : getfiboanswer($K,$R)
		}
	}
	Transition t0 whenRequest getfibo -> elab
	
}
/*
 * SERVICE 
 */
QActor servicemath context ctxservice {
	 
	State init initial { 
		println("$name  STARTS ") color blue
	}	
	Transition t0 whenRequest dofibo -> work
	 
	State work{
		onMsg( dofibo : dofibo(N) ){
			[#  
			   var ReqId  = currentMsg.msgId()
			   var ReqArg = payloadArg(0).toLong()
			   var Sender = currentMsg.msgSender()
			#]
			[# val SOUT = "$name | $ReqId $ReqArg Sender=$Sender" #]
			println("$SOUT") color blue
			//forward display -m out  : out(  $SOUT  )
			if[# ReqArg < 0 || ReqArg > 92 #]{
				[# val Wrong = "-1" #]
				replyTo dofibo with fibodone : fibodone($Sender,$ReqArg,$Wrong,0) //$Sender, $ReqArg, $F, $TF
			}
			else { delegateCurrentMsgTo actionexec }
			//create actionexecutor requestbycreator doaction : doaction ( $ReqId,$ReqArg,$Sender,name ) 
		}
	}  
	Transition t0   whenRequest dofibo    -> work

 }

QActor actionexec  context ctxservice withobj math using "utils.MathUtils.create()" dynamicOnly{
	[# var T0     = 0L 
	   var ReqArg = 0L
       var Sender = ""
    #]
	
	State init initial {
		//println("$name | STARTS ")  color cyan
    }	 
    Transition t0 whenRequest dofibo -> work
	
	State work{
		printCurrentMessage color green
		onMsg( dofibo : dofibo( N ) ){
			[#   
				ReqArg  = payloadArg(0).toLong() 
 				Sender  = currentMsg.msgSender() 
			#]  
			//println("$name | work N=$N ${sysUtil.curThread()}") color blue
			
			[# T0 = getCurrentTime() #]
			request storage -m getfibo : getfibo($ReqArg)
			
//			[# 
//			   val T0 = getCurrentTime()  
// 			   var F = math?.fibo( ReqArg.toInt() )  
// 			   val TF  = getDuration(T0)  
//			   val SOUT = "$name, fibo($ReqArg), $F, time=$TF" 
//			#]
//			println("$SOUT") color cyan
//			forward display -m show : show($SOUT)
//			replyTo dofibo with fibodone : fibodone($Sender, $ReqArg, $F, $TF)
// 			   
//			terminate 0
// 
//			[# var anames = sysUtil.getAllActorNames(context!!.name) #]
//			println("$name | AFTER: $anames")
		} 
	} 
	Transition t0 whenReply getfiboanswer -> sendAnswerToCaller
	
	State sendAnswerToCaller{
		onMsg( getfiboanswer : getfiboanswer(N,V) ){
			[#
				val TF  = getDuration(T0) 				
				val F   = payloadArg(1)
				val SOUT = "$name, ${payloadArg(0)} / fibo($ReqArg), $F, time=$TF" 
			#]
			println("$name | check $ReqArg==${payloadArg(0)}") color yellow
//			forward display -m show : show($SOUT)
			replyTo dofibo with fibodone : fibodone($Sender, $ReqArg, $F, $TF)
		}
		terminate 0
 
		[# var anames = sysUtil.getAllActorNames(context!!.name) #]
		println("$name | AFTER: $anames")
	}
 
 } 

 
Facade f port 8088 usingactor servicemath inctx ctxservice  
                   appl "unibo.servicefacade24.Servicefacade24Application" 
                   UserLibs -f "servicefacade24-1.0" -f "servicefacade24-1.0-plain"

